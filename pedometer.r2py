"""
<Program Name>
  pedometer.r2py

<Purpose>
  This is a script for walking step counter. Analysis of the sensor data 
  from accelerometer to detect the walking / running steps. Introducing
  pre-calibration stage, noise level threshold and moving average filter
  to accurate step detection for difference devices.

  *Note: the device must be stable for 1 second pre-calibration from beginning
"""




sensorlib = dy_import_module("sensorlib.r2py")
dy_import_module_symbols('getsensor.r2py')
dy_import_module_symbols('pre_calibration.r2py')
dy_import_module_symbols('moving_average.r2py')
dy_import_module_symbols('low_pass_filter.r2py')
dy_import_module_symbols('step_zero_detection.r2py')
dy_import_module_symbols('step_peak.r2py')

# Initilization for pre-calibration and constants
PRE_LEARN_SAMPLE_NUMBER = 100
MAX_TIME = 60		                      # Max program running time in seconds
MIN_STEP_INTERVAL = 0.25                  # Minimum time difference between each step in senconds




# get acceleration data from sensor
def mag_acceleration(data):
	return (data['xforce'] ** 2 + data['yforce'] ** 2 + data['zforce'] ** 2) ** 0.5


# log coefficient after pre-calibration stage
def log_coefficient(gravity_constant, moving_rate, threshold):
	log("Pre calibration done!\n")
	log("Grvaity Constant:", gravity_constant, 
			"\nMoving Average Filter Window Sampling Number:", moving_rate, 
			"\nThreshold:", threshold, '\n')
	log("Please walk around\n")





def pre_learn():
	# main
	log("Welcome to pedometer!\nSystem pre calibration, please wait a while\n")
	start_time = getruntime()
	count = 0
	
	while(count < PRE_LEARN_SAMPLE_NUMBER):
		try:
			current_time = getruntime()
			sensor_raw_data = get_sensors()

			# Before effecitve data collection, accelerometer return "None"
			# Continue except effective data collection
			if len(sensor_raw_data) == 0:
				continue
			count += 1

			# Pre-calibration stage initilization and data collection
			if count == 1:
				pre = PreCalibration(current_time)	
			pre.update(mag_acceleration(sensor_raw_data))
		except Exception as e:
		    log(str(e), '\n')
		    stop_sensing()



	# Get estimated coefficient at the end of pre-calibration stage
	gravity_constant = pre.get_gravity()
	moving_rate = pre.get_moving_rate(current_time)
	threshold = pre.get_threshold()

	# Initialize moving average filter and step detection
	MAF = MovingAverageFilter(moving_rate, current_time, 0.125)
	LPF = LowPassFilter(current_time, 0.25)
	step_z = StepZeroCrossing(threshold, current_time, MIN_STEP_INTERVAL)
	step_p = StepPeakSearch(threshold, current_time, MIN_STEP_INTERVAL * 2)
	log_coefficient(gravity_constant, moving_rate, threshold)
		
	return {'gravity_constant':gravity_constant, 'MAF':MAF, 'LPF':LPF, 'step_z':step_z, 'step_p':step_p}




class Pedometer:
	def __init__(self, coefficient):
		self.gravity_constant = coefficient['gravity_constant']
		self.MAF = coefficient['MAF']
		self.LPF = coefficient['LPF']
		self.step_z = coefficient['step_z']
		self.step_p = coefficient['step_p']
		self.activate = False


	def _step_counter(self):	
		# Startup step counter
		def func():
			while(self.activate):
				try:
					current_time = getruntime()
					sensor_raw_data = get_sensors()	
					# Non-gravity acceleration
					sensor_data_noG = mag_acceleration(sensor_raw_data) - self.gravity_constant


					# moving average filter
					mag_MAF = self.MAF.moving_average_filter(sensor_data_noG, current_time)

					# linear phase low pass filter
					mag_LPF = self.LPF.low_pass_filter(sensor_data_noG, current_time)


					# step detection
					self.step_z.zero_counter(mag_LPF, current_time)
					self.step_p.peak_search(mag_LPF, current_time)



				except Exception as e:
				    log(str(e), '\n')
				    sleep(0.005)
			
			log("Step counter finished, thank you for your help!\n")
		return(func)


	def start(self):
		self.activate = True
		createthread(self._step_counter())

	def stop(self):
		self.activate = False


def start_pedometer():
	step = Pedometer(pre_learn())
	step.start()
	return step

def stop_pedometer(step):
	step.stop()
	sleep(0.1)






# -*- mode: python;-*-
