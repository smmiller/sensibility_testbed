"""
<Program Name>
  pedometer.r2py

<Purpose>
  This is a script for walking step counter. Analysis of the sensor data 
  from accelerometer to detect the walking / running steps. Introducing
  pre-calibration stage, noise level threshold and moving average filter
  to accurate step detection for difference devices.

  *Note: the device must be stable for 1 second pre-calibration from beginning
"""




sensorlib = dy_import_module("sensorlib.r2py")
dy_import_module_symbols('getsensor.r2py')
dy_import_module_symbols('pre_calibration.r2py')
dy_import_module_symbols('moving_average.r2py')
dy_import_module_symbols('lpf.r2py')
dy_import_module_symbols('step_detection.r2py')
dy_import_module_symbols('steplib.r2py')
dy_import_module_symbols('step_peak.r2py')

# Initilization for pre-calibration and constants
PRE_LEARN_SAMPLE_NUMBER = 100
MAX_TIME = 60		                      # Max program running time in seconds
MIN_STEP_INTERVAL = 0.25                  # Minimum time difference between each step in senconds
lock = createlock()

count = 0

start_sensing(2, 0)
log("Welcome to pedometer!\nSystem pre calibration, please wait a while\n")
start_time = getruntime()


def write_file(filename, string, myfilelist):
	if filename in myfilelist:
		removefile(filename)
	myfileobject = openfile(filename, True)
	myfileobject.writeat(string, 0)
	myfileobject.close()



def step_counter():	
	# Startup step counter
	rawString = "Time, mag\n"
	resultString = "Time, mag\n"
	#stepString = "Time, step_count\n"
	#peakString = "Time, mag\n"
	averageString = "Time, mag\n"
	peakcount = 0
	stepcount = 0
	while(getruntime() - start_time < MAX_TIME):
		try:
			current_time = getruntime()
			sensor_raw_data = get_sensors()	

			# Non-gravity acceleration
			sensor_data_noG = mag_acceleration(sensor_raw_data) - gravity_constant

			rawString += str(current_time) + ',' + str(sensor_data_noG) + '\n'

			# moving average filter
			moving_magNoG = MAfilter.filter_mag(sensor_data_noG, current_time)
			averageString += str(current_time) + ',' + str(moving_magNoG) + '\n'

			# linear phase low pass filter
			filtered_magNoG = lpfoutput.filter_mag(sensor_data_noG, current_time)

			resultString += str(current_time) + ',' + str(filtered_magNoG) + '\n'

			# step detection
			step._step_counter(filtered_magNoG, current_time)


			# write to string
			if stepcount != step._get_step_count():
				stepcount += 1
				#stepString += str(current_time) + ',' + str(stepcount) + '\n' 


			step_p._step_counter(filtered_magNoG, current_time)
			if peakcount != step_p._get_count():
				peakcount += 1
				#peakString += str(step_p._get_maxtime()) + ',' + str(step_p._get_peak()) + '\n' 

		except Exception as e:
		    log(str(e), '\n')
		    sleep(0.005)
	
	# Stop sensing while times over
	stop_sensing()


	# write to file
	myfilelist = listfiles()

	write_file("raw", rawString, myfilelist)
	#write_file("peaksearch", peakString, myfilelist)
	#write_file("stepcount", stepString, myfilelist)
	write_file("filtered", resultString, myfilelist)
	write_file("average", averageString, myfilelist)
	
	log("Step counter finished, thank you for your help!\n")





# main
while(getruntime() - start_time < MAX_TIME):
	try:
		current_time = getruntime()
		sensor_raw_data = get_sensors()

		# Before effecitve data collection, accelerometer return "None"
		# Continue except effective data collection
		if len(sensor_raw_data) == 0:
			continue

		count += 1

		# Pre-calibration stage initilization and data collection
		if count > 0 and count < PRE_LEARN_SAMPLE_NUMBER:
			if count == 1:
				pre = pre_calibration(current_time)	
			pre._update(mag_acceleration(sensor_raw_data))



		# Get estimated coefficient at the end of pre-calibration stage
		elif count == PRE_LEARN_SAMPLE_NUMBER:
			gravity_constant = pre._get_gravity()
			moving_rate = pre._get_moving_rate(current_time)
			threshold = pre._get_threshold()

			# Initialize moving average filter and step detection
			MAfilter = moving_average_filter(moving_rate, current_time, 0.125)
			lpfoutput = lpf(current_time, 0.25)
			step = step_detection(threshold, current_time, MIN_STEP_INTERVAL)
			step_p = step_peak(threshold, current_time, MIN_STEP_INTERVAL * 2)
			log_coefficient(gravity_constant, moving_rate, threshold)
			break
	except Exception as e:
	    log(str(e), '\n')
	    stop_sensing()
    
createthread(step_counter)


# -*- mode: python;-*-
