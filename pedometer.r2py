"""
<Program Name>
  pedometer.r2py

<Purpose>
  This is a script for walking step counter. Analysis of the sensor data 
  from accelerometer to detect the walking / running steps. Introducing
  pre-calibration stage, noise level threshold and moving average filter
  to accurate step detection for difference devices.

  *Note: the device must be stable for 1 second pre-calibration from beginning
"""




sensorlib = dy_import_module("sensorlib.r2py")
dy_import_module_symbols('getsensor.r2py')
dy_import_module_symbols('pre_calibration.r2py')
dy_import_module_symbols('moving_average.r2py')
dy_import_module_symbols('step_detection.r2py')
dy_import_module_symbols('steplib.r2py')


# Initilization for pre-calibration and constants
PRE_LEARN_SAMPLE_NUMBER = 100
MAX_TIME = 60		                      # Max program running time in seconds
MIN_STEP_INTERVAL = 0.25                  # Minimum time difference between each step in senconds
lock = createlock()

count = 0

start_sensing(2, 0)
log("Welcome to pedometer!\nSystem pre calibration, please wait a while\n")
start_time = getruntime()


# pre-calibration stage
def pre_learned(sensor_raw_data):
	def func():
		lock.acquire(True)
		################################### CRITICAL REGION #######################################

		pre._update(mag_acceleration(sensor_raw_data))

		################################# ENDOF CRITICAL REGION ###################################
		lock.release()
	return func


def step_counter(sensor_raw_data, gravity_constant, current_time):
	def func():
		lock.acquire(True)
		################################### CRITICAL REGION #######################################

		# Non-gravity acceleration
		sensor_data_noG = mag_acceleration(sensor_raw_data) - gravity_constant

		# moving average filter
		filtered_magNoG = filter.filter_mag(sensor_data_noG, current_time)

		# step detection
		step._step_counter(filtered_magNoG, current_time)

		################################# ENDOF CRITICAL REGION ###################################
		lock.release()
	return func


# main
while(getruntime() - start_time < MAX_TIME):
	try:
		current_time = getruntime()
		sensor_raw_data = get_sensors()

		# Before effecitve data collection, accelerometer return "None"
		# Continue except effective data collection
		if len(sensor_raw_data) == 0:
			continue

		count += 1

		# Pre-calibration stage initilization and data collection
		if count > 0 and count < PRE_LEARN_SAMPLE_NUMBER:
			if count == 1:
				pre = pre_calibration(current_time)	
			createthread(pre_learned(sensor_raw_data))



		# Get estimated coefficient at the end of pre-calibration stage
		elif count == PRE_LEARN_SAMPLE_NUMBER:
			gravity_constant = pre._get_gravity()
			moving_rate = pre._get_moving_rate(current_time)
			threshold = pre._get_threshold()

			# Initialize moving average filter and step detection
			filter = moving_average_filter(moving_rate, current_time)
			step = step_detection(threshold, current_time, MIN_STEP_INTERVAL)
			log_coefficient(gravity_constant, moving_rate, threshold)
			break
	except Exception as e:
	    log(str(e), '\n')
	    stop_sensing()
    

while(getruntime() - start_time < MAX_TIME):
	try:
		current_time = getruntime()
		sensor_raw_data = get_sensors()
		count += 1
		# Startup step counter
		createthread(step_counter(sensor_raw_data, gravity_constant, current_time))
	except Exception as e:
	    log(str(e), '\n')
	    stop_sensing()




stop_sensing()

# -*- mode: python;-*-
